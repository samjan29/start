# day03

컴퓨터가 숫자를 기억하는 방법
	정수의 경우
		==>	2진수로 변환하고 부호 비트는 무조건 0을 붙인다.
			예 ]
					10
				2	5	0	(첫번째)
				2	2	1
				2	1	0
				2	0	1
				따라서 10의 2진수는 0(부호 비트)0001010
				
	음수의 경우
		==> 9의 보수법을 이용해서 처리한다.
			1) 양수로 가정하고 2진수로 변환한다.
			2) 보수화 시킨다. (0 -> 1, 1 -> 0)
			3) + 1을 해준다.
			4) 부호 비트를 1로 지정한다.
			
------------------------------------------------------------------------------------------

연산자 ==> 데이터를 가공하기 위해서 사용되는 기호
	용어
		연산자		- 가공방식을 나타내는 기호
		피연산자	- 가공에 사용되는 데이터
		
		예 ]
			1 + 2 ==> + : 연산자, 1과 2는 피연산자
			
		참고 ]
			연산자를 사용하면 가공된 결과가 나오는데 이 결과는 항상 큰 형태로 나오는 것을 원칙으로 한다.
			
			예 ]
				1 + 3.14 = 4.14 이때 결과값의 데이터 형태는 double
				
				int + double = double (결과 = 큰 형태, int는 double로 자동 형변환)
				
				float + long = float (실수가 항상 정수보다 크므로)
				
				문제 ]
						'J' + 3.14 ==> ?
						
						'J'는 아스키 코드값 74로 변환이 되서 연산
						74 + 3.14를 연산 -> 결과값 double형 데이터 77.14
				
				참고 ]
					기본 데이터 타입 + 문자열 데이터 ==> 문자열
					
					예 ]
						3.14 + "!!!!" ==> 3.14!!!!
						이때 + 는 산술연산자가 아니라 데이터 2개를 결합하는 결합연산자로 작동된다.
				
			주의 ]
				수학에서는 비교연산을 할때 3개의 항을 동시에 비교할 수 있었지만
				프로그래밍에서는 절대로 3개 이상의 피연산자를 동시에 연산하지 않는다.
				수학에서 사용하는 방식 : 1 < x < 10
				자바에서 사용하는 방식 : x > 1 and x < 10
				
-------------------------------------------------------------------------------------------------------------

연산자 종류
	1. 사칙연산자
		==> 더하고 빼고 곱하고 나누고 나머지 구하는 연산자
			기호
				+
				-
				*
				/
				%
				
			참고 ]
				사칙연산자는 피연산자가 반드시 2개가 필요하다.
				참고 ]
					사칙연산자가 여러개 동시에 기술된 경우에는 왼쪽부터 차례대로 계산해 결과를 낸다.
	
	2. 대입연산자 *
		==> 변수에 데이터를 기억하도록 하는 연산자
			기호
				=
				+=
				-=
				*=
				/=
				%=
				
			형식 ]
				변수 = 데이터; * 반드시 대입연산자 왼쪽에는 변수가 오른쪽에는 데이터가 위치해야 함.
				(오른쪽에서 왼쪽으로)
			의미 ]
				데이터를 변수에 기억시킨다.
			참고 ]
				자바는 모든 연산이 반드시 대입연산자가 있어야 기억할 수 있다.
				(연산 자체는 CPU에서 일어남. 소스코드 -> 메모리(RAM) -> CPU)
				만약 대입하지 않으면 연산의 결과는 기억되지 못한다.
		참고 ]
			모든 연산자는 같은 연산자가 중복된 경우 왼쪽에서 오른쪽으로 진행하면서 연산한다.
				예 ]
					1 + 2 + 3 + 4 + 5
						1 + 2 
								+ 3
									+ 4
										+ 5
					이런 순서로 연산을 진행하는데 대입연산자 만큼은 오른쪽에서 왼쪽으로 진행한다.
					예 ]
						int a = 10;
						int b = 20;
						int c = 30;
						int d = 40;
						
						a = b = c = d;
						<------------	방향으로 대입연산 진행
						
			참고 ]
				변수 = 변수 + 데이터;
				==> 변수 += 데이터;
						
				
참고 ]
	+ 기호는 문자열 연산에서도 사용할 수 있다.(문자열 연산은 오직 + 기호만 사용할 수 있다)
	==> 이때 문자열이 결합돼서 결과가 만들어진다.
		결합이란?	앞 문자열에 뒤 문자열이 붙어서 만들어지는 것
		"홍" + "길동" ==> "홍길동"
		
		참고 ]
			모든 기본 데이터 타입의 데이터를 문자열에 결합하면 결과는 문자열이 만들어진다.
			'홍' + "길동" ==> "홍길동"
			
	참고 ]
		문자열 결합은 문자열이 단 한개만 있어도 허용된다. 결합하는 두 항 중 하나만 문자열이라도 문자열로 결합
		예 ]
			"홍" + 1000 ==> "홍1000"
			200 + "홍" ==> "200홍"
			
	참고 ]
		System.out.println(데이터)에서는 오직 한개만 출력(여러개 나열해서 넣지는 못함)
		예 ]
			+(결합) 연산자를 쓰는 이유
			System.out.println("홍길동", "고길동", "둘리"); (X)

		여러개를 출력하려면 문자열 결합으로 하나의 문자열로 결합해 출력해야 함				
	
				
	3. 증감연산자
		형식 ]
			++변수
			변수++
		기호 ]
			++	: 1증가
			--	: 1감소
			
		참고 ]
			모든 연산은 일반적으로 중앙처리장치에서 처리되는 것이 원칙
			증감연산자, 시프트연산자는 중앙처리장치를 거치지 않는다.
			메모리 상에서 연산되서 처리된다. (속도가 빠름)
	
	4. 부호반전연산자
		기호 ]
			-
		형식 ]
			-데이터;
	
	5. 비교연산자
		==> 두 데이터의 대소 관계를 비교하는 연산자
		기호 ]
			==
			!=
			>
			<
			>=
			<= ; =>, =< 는 정의가 안되어있다. 무조건 부등호 뒤에 와야함
			
		주의 ]
			사용되는 데이터와 관계없이 결과는 항상 논리값(true, false)
			
		참고 ]
			이 연산자는 주로 if, for, while, ... 제어 명령에서 질문이 필요할때 많이 사용되는 연산자
		
		참고***** ]
			문자열을 비교할 경우에는 equals()를 사용해서 비교해야 데이터를 정확하게 비교할 수 있다.
			(아니면 주소값만 비교하게 됨)
			
		참고 ]
			비교연산자는 3항을 동시에 비교하지 못함
			예 ]
				10 <= no < 100 (X)
				no >= 10 and no < 100 (O)
			 
	6. 논리연산자
		기호 ]
			&
			|
			&&
			||
			!
		
	7. 비트연산자
	
	8. 3항연산자(조건연산자)
	
	