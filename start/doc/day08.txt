# day08

배열의 복사
	종류 ]
		1. 얕은 복사
			==> 주소만 복사하는 방법
			
			특징 ]
				데이터는 공유하기 때문에 한곳에서 수정하면 다른 곳에서도 수정된 내용을 사용
				
			방법 ]
				int[] a = new int[5];
				...
				
				int[] b;
					이 변수는 배열의 주소를 기억할 변수를 만들어준 것
					b 안에는 데이터는 기억할 수 없고 오직 같은 Heap 타입의 int[]의 주소만 기억할 수 있다.
				
				b = a;	==> 얕은 복사가 된다. a에서 만든 배열을 같이 공유하게 된다.
				
			참고 ]
				얕은 복사는 
				지역변수는 그 지역에서만 사용할 수 있으므로 다른 지역에서 Heap 영역의 데이터를 사용할 목적으로 많이 사용되는 방법
				/ Heap에 저장된 데이터는 프로그램이 종료되기 전까진 계속 유지된다. 용량이 다 찰 경우 안쓰는 데이터를 지워서 공간을 확보한다.
				
				
		2. 깊은 복사
			==> 데이터를 복사하는 방법
			
				데이터가 복사 되었다는 것은 Heap 영역에 다른 인스턴스(new 명령으로 생겨난 결과물)가 만들어졌다는 것이므로
				변수가 기억하는 주소가 달라지게 되므로
				***
				복사된 데이터는 독립적으로 사용된다.
				
			방법 ]
				명령을 사용해서 처리하면 된다.
				
				System.arraycopy(#1, #2, #3, #4, #5);
				
					#1	-	원본 배열의 주소
					#2	-	원본 배열의 복사를 시작할 위치
					#3	-	복사 받을 배열의 주소
					#4	-	복사 받을 배열의 시작 위치값
					#5	-	복사 받을 데이터의 갯수
					
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
				
배열의 단점
	1. 한번 배열의 크기를 정하면 크기 조절이 불가능하다.
	
	예 ]
		int[] no1 = new int[10];
		...
		// 작업을 하다가 10개를 추가해야되는 경우
		int[] no2 = new int[20];
		
		// 데이터 복사
		System.arraycopy(no1, 0, no2, 0, 10);
		
		// 추가데이터 입력
		no2[10] = ???;
		no2[11] = ???;
		
	2. 같은 형태의 데이터만 관리할 수 있다.
		==>	주소는 Heap 타입에 의해서 결정이 되고 Heap Type이 다르면 사용할 수 없다.
				
			예 ]
				
				int[] a = new int[10];
				
				float[] b;
				
				b = a; ==> 절대로 안된다.
				
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
				
String 배열
	
	참고 ]
		String 역시 참조형 타입이다.
		
		String str = "Hong";
		
		str에는 데이터 자체의 주소가 기억되고
		
		String str = new String("Hong");
		라고 변수를 만들면 변수는 Heap에 만들어진 인스턴스의 주소를 기억하고 인스턴스가 데이터의 주소를 기억한다.
		

	String 배열 만들기
	
		String[] str;	// 배열변수 선언, 데이터를 사용할 준비
		str = new String[5];
		==> 데이터가 초기화가 안되어있는 상태
			아직 각 인덱스가 비어있는 상태(데이터가 결정이 안되어있는 상태)
			
		str[0] = "Hong";
		str[1] = "Dooly";
		==> 위처럼 데이터 공간까지 만들어줘야 한다.
		
		String 배열도 초기화가 가능하다.
		
		String[] names = {"둘리", "제니", "리사", "로제", "지수"};
		
	
	참고 ]
		문자열도 필요에 따라서 char[] 형태로 변환해서 사용할 수 있다.
		
		방법 ]
			toCharArray();
			
		예 ]
			String name = "jenie";
			
			char[] ch = name.toCharArray();
			
			ch[0] ==> j
			ch[1] ==> e
			
	
	참고 ]
		String 클래스에서 자주 사용되는 함수
			
			1. charAt(위치값)
				==> 해당 위치의 문자를 알려준다.
				
			2. length()
				==> 문자열의 길이를 알려준다.
				
			3. substring()		
				==> 문자열 중에서 원하는 문자열만 따로 뽑아서 반환해준다.
				형식 1 ]
					substring(시작위치);
					==> 시작위치에서부터 맨 마지막까지 모두 추출해준다.
				형식 2 ]
					substring(시작위치, 종료위치);
					==> 시작위치에서부터 종료위치 이전 문자까지 추출해준다.

					**
					주의 ]
						시작위치는 0부터 카운트해서 지정한다.
						종료위치는 1부터 카운트해서 지정한다.
						
					
			4. equals()	
				==> 문자열의 데이터 자체가 같은지 비교해서 논리값으로 반환해주는 함수
			
				
				
2차원 배열
	==> 1차원 배열을 관리하는 배열
		==> 배열 안에 다시 배열이 들어있는 형태
			(정확히는 배열 안에 1차원 배열의 주소가 기억된다. 배열이 들어있는게 아니다!)
			
	2차원 배열 만드는 방법
		1. 배열 주소를 기억할 변수를 만든다.
			==> Heap 영역에 있는 데이터는 주소를 알아야 사용하기 때문이다.
			
			방법 ]
				데이터타입[][]	변수이름;
				==> []가 1개이면 1차원 배열이 되고
					2개이면 2차원 배열
					3개면 3차원 배열
					...
					
			예 ]
				int[][] num;
				
				num = new int[5];	===> X : Heap type이 달라서 안된다.
				
		2. 1차원 배열을 몇개를 관리할지를 결정하고 1차원 배열의 주소를 기억할 메모리를 만든다.
		
			방법 ]
				new 데이터타입[갯수][];
				==> 갯수는 1차원 배열의 갯수를 지정한다.
				
			예 ]
				num = new int[5][];
				
		3. 실제 정수를 관리하는 1차원 배열의 길이를 결정하고 1차원 배열의 주소를 기억할 메모리를 만든다.
		
			방법 ]
				new		데이터타입[갯수];
				
			예 ]
				num[0] = new int[3];
				
				
	참고 ]
		2차원 배열도 사각형 형태의 배열을 만들 수 있다.
		
		형식 ]
			데이터타입[][]		변수 = new		데이터타입[행 수][열 수];
			
		예 ]
			int[][] num = new int[5][3];
			==> 정수 3개를 관리하는 배열 5개를 관리하는 배열		
			
		주의 ]
			이해를 돕기 위해서 사각형으로 설명하지만
			실제로는 별도의 메모리 공간을 차지하는 배열이 만들어지고
			그 배열을 관리하는 배열이 다시 만들어진다.	==>	메모리 공간이 아니라 주소만 취한다는 것!
		
				
	참고 ]
		2차원 배열도 초기화가 가능하다.
		
		방법 ]
		
			int[] num = {데이터1, 데이터2, ...};	==> 데이터의 갯수만큼 만들어지고 입력된 데이터로 초기화가 된다.
			
			int[][]	num = {{1, 2}, {3, 4, 5}, {6, 7, 8, 9}};
			==> 여기서도 배열의 갯수를 지정할 수는 없다.
				
				
				
				
				
				
				