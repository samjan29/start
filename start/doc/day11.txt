# day11

this
==> 교과서적인 의미로는
	현재 실행중인 객체의 주소를 기억하는 약속
	
	이것은 JVM이 클래스를 처리하기 위해서 JVM이 사용하는 변수
	즉, 개발자는 거의 이 변수를 사용하지 않는다.
	
	규칙 ]
		1. 모든 멤버는 사용할 때 반드시 앞에 주소가 있어야 한다.
		   멤버는 클래스 안에 만들어진 변수나 함수를 이야기 한다.
		   
		   따라서 new를 시킨 후 그 주소를 기억해 놓았다가
		   그 주소를 이용해서 사용하는 것이다.
		   
		2. 만약 주소가 없으면 JVM이 자동적으로 this를 붙여준다.
		
		3. 멤버 함수를 호출할 때는 무조건 주소값을 함수에게 알려주도록 약속되어있고
			함수는 this 변수를 준비한 후
			함수를 호출할 때 알려준 주소를 기억하게 된다.
			
	참고 ]
		딱 한번 개발자가 this를 사용해야 하는 경우가 있는데
		
		가끔은 지역변수와 멤버변수가 이름이 동일하게 만들어지는 경우가 있다.
		이러면 그 함수는 지역변수를 우선적으로 사용하게 된다.
		따라서 멤버변수(전역변수)에는 데이터가 기억되지 않을 수 있다.
		
		*
		이때 굳이 이 변수가 멤버변수임을 꼭 반드시 밝혀야되는 경우가 생기면 이때 강제로 this라고 써주면 된다.
	
======================================================================================================================================================================

속성
	
	static 속성
	==> staitc 영역에 생기는 함수나 변수에 붙여주는 속성
	
		참고 ]
			클래스, 함수, 변수를 만들때 속성을 지정할 수 있다.
			
			예 ]
				접근지정자		[속성]		class	클래스이름 {}
				접근지정자		[속성]		반환값타입		함수이름(매개변수리스트) {}
				접근지정자		[속성]		데이터타입		변수이름;
				
		static 영역의 특징
			1. 프로그램이 실행되기 위해서 JVM이 로딩되는 순간 저절로 생기는 영역이다.
				즉, 사용자가 특별히 만들어 달라고 요구하지 않아도 자동적으로 생긴다.
				
			***
			2. 한번 생긴 변수나 함수는 두번 다시 생기지 않는다. 
			
		static 변수
		==> static 영역에 만들어지는 변수
		
			형식 ]
				접근지정자		static		[속성]		데이터타입		변수이름;
				
				예 ]
					public static final int BLACK = 1004;
					
			특징 ]
				1. 여러 오브젝트(객체)가 공동으로 사용하는 변수
					왜??
						오브젝트를 100개를 만들어도 static 변수는 static 영역에 한번만 올려지기 때문에
						따라서 한 오브젝트가 데이터를 바꾸면 다른 오브젝트들도 바뀐 데이터를 사용해야 한다.
						
						따라서 결국 static 변수는 오브젝트의 의미가 없다. 그리고 오브젝트가 없어도 사용할 수 잇다.
						
				2. new 시키지 않아도 사용할 수 있는 변수
					왜??
						이미 static 영역에 올려져 있기 때문에

					사용방법 ]
						클래스이름.변수이름;
						

		static 함수
		==> staitc 변수와 마찬가지로 static 영역에 올려지는 함수
			따라서 객체를 만들지 않아도 사용할 수 있는 함수
			
			사용방법 ]
				클래스이름.함수이름();
				
			특징 ]
			==> this를 사용할 수 없는 함수
			
		**
		결론 ]
			static 함수 안에서는 메모리에 올려진 것들만 사용할 수 있다.
			일반함수 안에서는 static 멤버 그리고 일반 멤버도 사용가능하다.
			
---------------------------------------------------------------------------------------------------------------------------------------------------------------------

멤벼 변수의 초기화
==> 멤버 변수는 Heap 영역에 생기므로 자동 초기화가 된다.
	하지만 가끔은 변수에 기본적인 값을 지정할 필요가 있다.
	
	1. 명시적 초기화
		==> 변수를 선언하면서 값을 대입하는 것
			가장 먼저 실행되는 방법
			
			예 ]
				class Test {
					int no = 10; ==> 명시적 초기화
				}
				
	2. 초기화 블록을 이용한 초기화
		==> 이것은 인스턴스 변수에 한해서만 가능한 방법으로
			두번째로 실행되는 방법
			
			방법 ]
				{
					이 안에서 데이터를 변수에 입력;
				}
	
	3. static 블록을 이용한 초기화
		==> 위의 2번과 마찬가지로 static 변수에 한해서만 가능한 방법
			두번째로 실행되는 방법
			
			형식 ]
				static { // ==> static 초기화 블록
					데이터입력
				}
				
			예 ]
				class Test {
					static int no;
					
					static {
						no = 100;
					}
				}
	
	4. 생성자를 이용한 초기화
		==> 가장 마지막에 실행되는 방법
		
			예 ]
				class Test {
					int no;
					
					public Test() {
						no = 100;		// 생성자를 이용한 초기화
					}
				}
				
====================================================================================================================================================================

객체지향 언어의 특징
	1. 상속
	2. 다형성
	3. 은닉화 / 캡슐화

====================================================================================================================================================================

상속 ]
	==> 이미 만들어진 클래스의 기능을 그대로 부여받아서
		(변수와 함수의 기능을 그대로 복사해 와서)
		새로운 클래스를 만드는 방법
		
		소프트웨어 개발 속도가 빠르게 하기 위한 방법의 한가지
		
		즉, 상속은 객체지향에서 매우 중요한 역할을 하는 것으로 객체 지향 언어는 부품 단위(클래스)로 프로그램을 만든 후
		그 부품을 조립해서 원하는 결과를 얻어내는 것이다.
		
		어딘가에서 부품(클래스)을 구했는데
		그 기능이 사용자 마음에 꼭 맞지는 않을 수도 있다.
		이때 처음부터 다시 만들어야 하나??
		라는 문제에서 이 문제를 해결하기 위해 만들어진 방법이 "상속"이다.
		
		상속은 자신이 만들고자 하는 부품과 가장 유사한 부품을 가지고 와서
		일단 그 기능을 다 복사한 후
			1. 없는 기능은 더하고
			2. 수정할 기능은 수정하고
		
		상속하는 형식 ]
			접근지정자		[속성]		class		클래스이름		extends		복사해올 클래스이름 {
			
			}
			
		***
		참고 ]
			자바는 오직 단일 상속만 가능하다.
			즉, 상속은 오직 한개의 클래스에서만 받을 수 있다.
			
			예 ]
				class NewClass extends Old1, Old2 {}	==> X
				
				class NewClass extends Old {}	==> O
				
		용어 ]
			상속을 해준 클래스	==> 상위 클래스(Super Class)	(부모 클래스)
			상속을 받은 클래스	==> 하위 클래스(Sub Class)		(자식 클래스)
			
			
			is a		==> 상속 관계에 있는 클래스를 부르는 용어
				
							class Father {}
							class Son extends Father {}
							
							==> Son is a Father	가 성립된다.
			
			has a		==> 어떤 클래스 안에 다른 클래스를 멤버로 가지고 있는 상태
			
							class Father {}
							class Son {
								Father f = new Father();
							}
							
							==>	Son has a Father 가 성립된다.
							
	상속 관계에 있는 경우 생성자의 역할
	
		하위 클래스가 생성되는 순간
		상위 클래스의 객체가 자동 생성된다.
		==> 생성되는 순간 생성자 함수가 호출된다.
			따라서 하위 클래스를 생성하면 상위 클래스의 기본생성자 함수도 실행된다.
			
		상위 클래스의 생성자 함수는 자동 호출된다.
		자동 호출되는 경우는 무조건 기본 생성자만 이용하게 된다.
		
	***
	참고 ]
		super()
			==> 상위 클래스의 특별한 생성자를 강제로 호출하는 기능을 가진 명령
				현재 클래스의 생성자 함수에서 상위 클래스의 생성자를 호출하는 유일한 방법
		
			특징 ]
				1. 반드시 생성자 함수 안에서만 사용해야 한다.
				2. 반드시 첫줄 첫문장으로만 올 수 있다.
				
			예 ]
				class Father {
					int no;
					public Father()	{
					}
					public Father(int no)	{
						this.no = no;
					}
				}
				
				class Son extends Father {
					char ch;
				
					public Son() {}
					public Son(int no, char ch) {
						super(no);
						this.ch = ch;
					}
				}
				
====================================================================================================================================================================

*****
함수의 오버라이딩(Overriding : 함수의 재정의)
==> 상속관계에 있는 하위 클래스에서 상위 클래스가 물려준 함수의 기능을 수정하는 행위

	방법 ]
		0. 상위 클래스에 함수가 존재해야 한다.
		
		1. 상위 클래스가 가진 함수의 원형(Prototype)과 동일한 원형으로 만들어야 한다.
		
			참고 ]
				함수의 원형(Prototype)
				반환값 + 함수이름 + 매개변수리스트
				
		2. 접근지정자는 같거나 넓은 방향으로 기술한다.
		
		3. 예외처리는 같거나 좁은 방향으로( 이후 다시 설명)
		
	오버라이딩을 하면 내부적으로 super의 함수가 숨겨지고 재정의한 함수가 사용된다.
	
		class Father {
			public void abc() {
				System.out.println("만세");
			}
		}	
			
			==>
		class Son extends Father {
			public void abc() {
				System.out.println("만세");
			}
		
			public void xyz() {
				super.abc();	==> 상속 받은 곳의 abc함수
				
				abc();			==> 같은 클래스의 abc함수
			}	
		}
			이 경우 상위 클래스의 abc함수 호출하는 방법
				super.abc();
				
	super
	==> this가 현재 실행중인 객체 자기자신을 기억하는 예약된 변수이듯이
		super 역시 예약된 변수 중 하나이다.
		자신의 상위 클래스의 객체의 주소를 기억하는 변수이다.
		
		사용목적 ]
			반드시 소속을 밝혀야하는 경우가 생길때 사용한다.
			
====================================================================================================================================================================

Object 클래스
==> 자바로 만들어진 모든 클래스들의 최상위 클래스의 역할을 하는 클래스
	따라서 자바로 만들어진 모든 클래스는 Object가 제공하는
	모든 기능(멤버 : 변수, 함수)을 자동적으로 사용할 수 있게 된다.
	
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	public class Abc {}		==> Object + alpha
	
	Object o = new Abc();	==> 다형성 (클래스 변수의 자동 형 변환)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	참고 ]
		최상위 클래스를 만들어 놓은 이유
			계층추적을 원할하게 하기 위한 조치
			즉, 각각의 클래스의 족보를 정확하게 따질 수 있도록 하기 위해서
			
	참고 ]
		자바로 만든 모든 클래스는 반드시 상위 클래스를 가지고 있다.
		우리가 지금까지 만든 클래스들도 상위 클래스를 가지고 있다.
		만약 강제로 상위 클래스를 지정하지 않으면("extends 클래스이름" 이라고 붙이지 않으면)
		암묵적으로 Object라는 클래스를 상속받아서 만들어진다.
		
	**
	instanceof
	==> 특정 클래스를 new 시키면 주소가 만들어지는데
		이 주소가 어떤 클래스 소속의 주소인지를 알아내는 연산자
		연산의 결과는 true 또는 false로 만들어진다.
		
		형식 ]
			주소	instanceof		클래스이름
			
		의미 ]
			주소가 가리키는 내용이 지정한 클래스 소속인지를 물어본다.
			(주소가 클래스 이름의 인스턴스니????)
			
		참고 ]
			소속이라는 개념은 is a 관게를 따지는 것이다.
			상속 관계를 따지는 개념이 소속이라는 것이다.
			
=====================================================================================================================================================================

package와 import
	package란?
	==> 자바 프로그램(소스코드)가 들어있는 폴더를 자바에서 부르는 용어
	
		자바는 오픈소스이다.
		모든 사람이 자신이 만든 프로그램을 제공할 수 있고 그것을 모든 사람이 이용할 수도 있다.
		그러다보니 문제점이 발생했는데 클래스이름이 충돌날 수 있다.
		이런 문제를 해결하기 위해서 만들어 놓은 한가지 방법이 바로 패키지이다.
		
		즉, 소스를 만드는 사람이 그 프로그램이 포함되는 폴더이름까지 정해서 프로그램을 만들도록 하는 것.
		
		결론적으로 자바로 프로그램을 만들때는 반드시 이 프로그램이 어떤 폴더에 저장되는지를 알려주도록 해놓았다.
		
		명령 ]
			package		폴더이름;
			
		참고 ]
			패키지 이름을 만드는 권장사항
			자신이 사용하는 도메인을 거꾸로 쓴 후 그 다음에 다시 폴더이름을 붙여서 만들어준다.
			이때 경로의 구분자는 / 를 쓰는것이 아니고 자바에서는 . 으로 구분해서 처리한다.
			
			예 ]
				githrd.com
				
				==>
					com.githrd.t0310
					
	import 란?
	==> 자신이 사용할 클래스가 어느 폴더(패키지)에 있는 클래스를 사용할 것인지를 밝혀주기 위한 명령
	
		예 ]
			내가
				Sample.Test.class
			Y씨
				ywai.Test.class
				
		==> Y씨의 프로그램을 사용하고 싶다.
		import ywai.Test;
		
		==>	내가 만든 Test를 사용하고 싶다
		import Sample.Test;
		
		형식 1 ]
			import 패키지경로. 클래스이름;
			==> 지정한 폴더의 지정한 클래스를 사용할 예정임을 밝히는 것
			
		형식 2 ]
			import 패키지경로.*;
			==> 지정한 경로에 있는 모든 클래스 중 일부를 사용할 예정임을 밝혀주는 것
			
			주의 ]
				t1 ------ s1 --- ....
					  |
					  |-- s2 --- Test1.java
					  |		  |- Test2.java
					  |		  |- Test3.java
					  |
					  |-- Test01.java
					  |-- Test02.java
					  
				이 경우
					import t1.*;
					==> Test01, Test02만 사용할 준비를 하게된다.
					
					만약 Test1을 사용하려면
					import t1.s2.*;	라고 별도로 import 해야한다.
					
				따라서 결론적으로 * 기호를 사용한 import 명령은 하위의 패키지 내의 클래스까지 사용할 준비를 하는것이 아니고
				직속 클래스만 사용할 준비를 하는 것이다.
				
	참고 ]
		2번 보다는 1번을 우선적으로 적용시킨다.
		
			예 ]
				sample.Test.java
				test.Test.java
				
				import test.Test;
				import sample.*;
				
				==> 사용하는 Test 클래스는 test 패키지의 Test 클래스를 사용하게 된다.
				
	참고 ]
		import를 하지 않아도 명시적으로 사용할 수 있는 패키지가 있는데 
		java.lang 패키지이다.
		왜냐하면 JVM이 기본적으로 찾아보는 패키지이기 때문이다.
		
	-------------------------------------------------------------------------------------------------------------------------------------
	
	static import
	==> static 멤버는 원칙적으로
				클래스이름.멤버이름		으로 사용한다.
				
		Math.PI
		Math.random()
		
		이때 static 멤버 앞에 사용하는 클래스이름 조차도 생략할 수 있다.
		==> 이처럼 static 멤버를 사용할 때 클래스이름을 생략할 수 있도록 하는 방법이 static import 이다.
		
		형식 ]
			import static 패키지경로.클래스이름.*;
			
			random()	==>		Math 클래스의 random() 함수를 호출하게 된다.
			
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

final 속성

	1. final 변수
		==> 이 변수는 값을 수정할 수 없는 변수이다.
			즉, 현재 값을 유지해야만 하는 변수
			<== 선언과 동시에 초기화를 하는 것이 일반적이다.
			
	2. final 함수
		==> 이 함수는 오버라이드(함수의 재정의)가 불가능한 함수
			따라서 이 함수는 매우 중요한 함수이므로 함부로 기능을 바꾸지 말고 현재 기능 그대로 사용하세요.
	
	3. final 클래스
		==> 이 클래스는 더 이상 상속이 불가능한 클래스임을 밝히는 속성
			기능을 추가 혹은 변경하지 말고 현재 기능 그대로만 이용하라는 의미의 클래스이다.
			
====================================================================================================================================================================

	상위 클래스의 타입 변수로 하위 클래스의 인스턴스를 기억하는 경우  
	(함수로 값을 재할당하지 않는다면)	변수는 레퍼런스 쪽을 따르고
	함수는 인스턴스 쪽을 따른다.
	
	단, 레퍼런스 쪽에 실행하려는 함수가 존재해야 한다.